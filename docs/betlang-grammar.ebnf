(* ============================================================================
   BetLang Grammar Specification (EBNF)
   Converted from: compiler/bet-parse/src/grammar.lalrpop

   BetLang: A probabilistic programming language for betting, auctions,
   and uncertainty-aware computation.
   ============================================================================ *)

(* ============================================================================
   LEXICAL ELEMENTS
   ============================================================================ *)

(* Keywords *)
keyword = "bet" | "let" | "in" | "fun" | "match" | "if" | "then" | "else"
        | "do" | "return" | "type" | "module" | "import" | "export"
        | "rec" | "and" | "or" | "not" | "xor"
        | "true" | "false" | "unknown"
        | "sample" | "observe" | "infer"
        | "parallel" | "weighted"
        | "MCMC" | "HMC" | "SMC" | "VI";

(* Literals *)
integer = [ "-" ], digit, { digit };
float = [ "-" ], digit, { digit }, ".", digit, { digit };
string_literal = '"', { character | escape_sequence }, '"';
identifier = letter, { letter | digit | "_" };
type_variable = "'", identifier;

letter = "a" | "b" | "c" | (* ... *) | "z" | "A" | "B" | (* ... *) | "Z";
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
character = (* any Unicode character except " and \ *);
escape_sequence = "\", ( "n" | "t" | "r" | "\" | '"' );

(* Operators *)
binary_op = "+" | "-" | "*" | "/" | "%" | "^"
          | "==" | "!=" | "<" | "<=" | ">" | ">="
          | "&&" | "||" | "++" | "::" | ">>" | "|>"
          | "<-" | "->" | "=>";

unary_op = "-" | "!" | "~" | "not";

(* Delimiters *)
delimiter = "(" | ")" | "[" | "]" | "{" | "}"
          | "," | ";" | ":" | "." | "=" | "@" | "|" | "_" | "?" | "\";

(* ============================================================================
   TOP-LEVEL STRUCTURE
   ============================================================================ *)

module = { item };

item = let_definition
     | type_definition
     | import_declaration
     | expression;

let_definition = "let", [ "rec" ], identifier, { pattern },
                 [ ":", type ], "=", expression;

type_definition = "type", identifier, { type_variable }, "=", type;

import_declaration = "import", identifier, { identifier }
                   | "import", identifier, { identifier }, ".", "{", identifier_list, "}";

identifier_list = identifier, { ",", identifier };

(* ============================================================================
   EXPRESSIONS
   ============================================================================ *)

expression = or_expression;

or_expression = and_expression, { ( "||" | "or" ), and_expression };

and_expression = compare_expression, { ( "&&" | "and" ), compare_expression };

compare_expression = add_expression, { comparison_op, add_expression };

comparison_op = "==" | "!=" | "<" | "<=" | ">" | ">=";

add_expression = mul_expression, { ( "+" | "-" | "++" ), mul_expression };

mul_expression = unary_expression, { ( "*" | "/" | "%" ), unary_expression };

unary_expression = [ unary_op ], application_expression
                 | "sample", application_expression;

application_expression = atom_expression, { atom_expression };

atom_expression = literal
                | identifier
                | bet_expression
                | weighted_bet_expression
                | lambda_expression
                | let_expression
                | if_expression
                | match_expression
                | do_expression
                | parallel_expression
                | tuple_expression
                | list_expression
                | record_expression
                | hole_expression
                | parenthesized_expression;

(* Literals *)
literal = integer
        | float
        | string_literal
        | "true"
        | "false"
        | "unknown"
        | "(" ")";  (* unit *)

(* Bet expressions *)
bet_expression = "bet", "{", expression, ",", expression, ",", expression, "}";

weighted_bet_expression = "bet", "{",
                          expression, "@", expression, ",",
                          expression, "@", expression, ",",
                          expression, "@", expression,
                          "}";

(* Lambda *)
lambda_expression = "fun", pattern, { pattern }, "->", expression;

(* Let *)
let_expression = "let", [ "rec" ], pattern, [ ":", type ], "=", expression,
                 "in", expression;

(* If *)
if_expression = "if", expression, "then", expression, "else", expression;

(* Match *)
match_expression = "match", expression, "{", { match_arm }, "}";

match_arm = pattern, [ "if", expression ], "->", expression, [ "," ];

(* Do notation *)
do_expression = "do", "{", do_statement, { ";", do_statement }, [ ";" ], "}";

do_statement = pattern, "<-", expression
             | "let", pattern, "=", expression
             | expression;

(* Parallel *)
parallel_expression = "parallel", atom_expression, "{", expression, "}";

(* Tuple *)
tuple_expression = "(", expression, ",", expression, { ",", expression }, ")";

(* List *)
list_expression = "[", [ expression, { ",", expression } ], "]";

(* Record *)
record_expression = "{", [ record_field, { ",", record_field } ], "}";

record_field = identifier, "=", expression;

(* Hole *)
hole_expression = "_"
                | "?", identifier;

(* Parenthesized / Type annotation *)
parenthesized_expression = "(", expression, ")"
                         | "(", expression, ":", type, ")";

(* ============================================================================
   PATTERNS
   ============================================================================ *)

pattern = or_pattern;

or_pattern = atom_pattern, [ "|", atom_pattern, "|", atom_pattern ];

atom_pattern = wildcard_pattern
             | variable_pattern
             | literal_pattern
             | tuple_pattern
             | list_pattern
             | parenthesized_pattern;

wildcard_pattern = "_";

variable_pattern = identifier;

literal_pattern = integer
                | float
                | string_literal
                | "true"
                | "false"
                | "unknown"
                | "(" ")";

tuple_pattern = "(", pattern, ",", pattern, { ",", pattern }, ")";

list_pattern = "[", [ pattern, { ",", pattern } ], "]";

parenthesized_pattern = "(", pattern, ")";

(* ============================================================================
   TYPES
   ============================================================================ *)

type = arrow_type;

arrow_type = application_type, [ "->", arrow_type ];

application_type = atom_type, { atom_type };

atom_type = named_type
          | type_variable
          | tuple_type
          | record_type
          | hole_type
          | parenthesized_type;

named_type = identifier;

tuple_type = "(", type, ",", type, { ",", type }, ")";

record_type = "{", [ record_type_field, { ",", record_type_field } ], "}";

record_type_field = identifier, ":", type;

hole_type = "_";

parenthesized_type = "(", type, ")";

(* ============================================================================
   PROBABILISTIC FEATURES
   ============================================================================ *)

(* Ternary Logic *)
ternary_value = "true" | "false" | "unknown";

(* Sampling *)
sample_expression = "sample", expression;

(* Observation *)
observe_statement = "observe", expression;

(* Inference *)
infer_statement = "infer", expression;

(* Inference Algorithms *)
inference_algorithm = "MCMC" | "HMC" | "SMC" | "VI";

(* ============================================================================
   END OF GRAMMAR
   ============================================================================ *)
